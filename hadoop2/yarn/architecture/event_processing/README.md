# 얀 이벤트 처리 방식
##### 얀이 동작할 때는 내부적으로 다양한 이벤트가 발생한다. 예를 들어, AMLauncher를 실행하거나 장애가 발생한 노드매니저를 리소스매니저에서 제거하는 작업은 이벤트 호출로 처리된다. 얀은 이벤트를 효율적으로 처리하기 위해 비동기 디스패처(AsyncDispatcher)와 스테이트머신(StateMachine) 모델을 제공한다.


## 1. 비동기 디스패처
##### 맵리듀스는 잡트래커와 태스크트래커의 내부 이벤트를 멀티 쓰레드 방식으로 처리한다. 멀티 쓰레드 방식은 각 요청마다 하나의 쓰레드를 새롭게 생성하는데, 쓰레드가 많아질 경우 시스템에 많은 자원을 소모하게 된다.(그래도 프로세스보단 낫겠다..)

##### 얀은 맵리듀스와는 달리 비동기 방식으로 이벤트를 처리하며, 이를 지원하기 위한 비동기 디스패처를 제공한다. 다음은 비동기 디스패처의 동작과정을 나타낸다.
![비동기 디스패처 동작 과정](https://github.com/googolhkl/TIL/blob/master/hadoop2/yarn/architecture/event_processing/AsyncDispatcher.png)

##### 1. 클라이언트는 비동기 디스패처의 handle 메소드를 호출해 이벤트 처리를 요청한다. 비동기 디스패처는 요청받은 이벤트를 내부 큐인 eventQueue에 등록한다. 이때 클라이언트는 이벤트 처리를 대기하지 않고, 다른 작업을 처리할 수 있다. (I/O작업과 비슷하군!)
##### 2. 비동기 디스패처는 이벤트 요청을 처리하는 eventHandlingThread를 제공한다. eventHandlingThread는 싱글 쓰레드로 실행되며, eventQueue에 신규 이벤트가 있는지 계속해서 조회한다. (폴링방식이란 말인가??)
##### 3. eventHandlingThread는 이벤트 요청 자체를 처리하지는 않으며, 실제 이벤트를 처리하는 클래스에게 전달하는 역할을 담당한다. 그래서 eventHandlingThread는 이벤트 처리 로직이 구현돼 있는 이벤트 핸들러의 handle 메소드를 호출한다.
##### 4. 이벤트 핸들러는 요청받은 이벤트 타입을 확인한 후 handle 메소드에 정의된 로직을 실해한다. 실제 얀에 구현된 이벤트 핸들러는 다양한 형태로 로직을 실행한다. 단순히 이벤트 로직만 실행하고 종료하거나, 또는 이벤트를 처리한 후 클라이언트에게 이벤트가 완료됐음을 알릴 수 있다. 마지막으로 이벤트 처리 중에 다른 이벤트를 발생시킬 수도 있다.

##### 비동기 디스패처는 싱글 쓰레드 기반으로 동작하기 때문에 멀티 쓰레드 방식의 문제점(동기화,데드락)같은 복잡한 상황을 벗어날 수 있다. 또한 기존 방식에 비해 속도도 빠르고 시스템 자원도 적게 소모한다. 참고로 현재 비동기 디스패처는 리소스매니저, 노드매니저, MRAppMaster에 적용돼 있다.

## 2. 상태 관리
##### 리소스매니저와 노드매니저의 내부 컴포넌트들은 상태 정보가 다양하게 변경된다. 예를 들어, 리소스매니저는 내부 컴포넌트로 RMNodeImpl을 사용한다. RMNodeImpl은 노드매니저의 상태정보를 제공하며, 다음과 같은 상태 정보로 구성된다.
##### - NEW : 신규 노드
##### - RUNNING : 정상적으로 실행되고 있는 노드
##### - UNHEALTHY : 실행 중이지만 문제가 있는 노드
##### - DECOMMISSIONED : 서비스에서 제외된 노드
##### - LOST : 리소스매니저에게 하트비트를 전송하지 않는 노드
##### - REBOOTED : :재부팅된 노드

##### RMNodeImpl은 위와 같은 범위 내에서만 상태가 변경된다. 예를 들어, 새로운 노드(NEW)가 실행 중인 노드(RUNNING)로 상태가 변경되거나 문제가 있던 노드(UNHEALTHY)가 정상 실행 중인 상태(RUNNING)로 변경될 수 있다. 이러한 상태 변경은 이벤트에 의해 처리된다. 
##### 하나의 컴포넌트는 다양한 상태와 상태변경이 발생한다. RMNodeImpl는 상태 정보가 적은 경우이고, 10개 이상의 상태를 처리하는 컴포넌트도 있다.

##### 얀은 이러한 상태 변경을 효율적으로 처리하기 위해 스테이트머신 모델을 제공한다. 이 모델은 상태 변경 정보와 관련 이벤트를 명시적으로 설정한다. 그래서 상태 변경을 자동으로 인지하고 관련된 로직을 처리할 수 있다. 또한 잘못된 상태 전환이 발생했을 때 자동으로 장애가 처리가 되도록 설정할 수 있다. 마지막으로 비동기 디스패처와 연계해 이벤트를 처리하기도 편하다.

##### 스테이트머신 모델은 다음과 같이 두 개의 클래스로 구성된다.

#### - StateMachine
##### 현재 상태와 각 상태가 됐을 때 처리해야 할 이벤트 정보로 구성된다.
#### - StateMachineFactory
##### 상태 변경 정보를 스택에 유지하고 있다. 변경 전의 상태 정보는 Enum 타입의 변수로 설정하고, 변경 후의 상태 정보는 이벤트 타입과 관련 메소드 정보를 이용해 StateMachine 객체를 생성한다. 참고로 Enum 변수는 하나만 설정할 수 있지만 변경 후 상태 정보는 여러 개의 StateMachine을 설정할 수 있다.

##### 마지막으로 스테이트머신 모델의 동작 과정을 알아보겠다. 다음은 RMNodeImpl의 상태가 REBOOTED로 변경됐을 때 처리 과정을 나타낸다.
![스테이트머신 동작 과정](https://github.com/googolhkl/TIL/blob/master/hadoop2/yarn/architecture/event_processing/StateMachine.png)

##### 각 동작은 다음과 같다.
##### 1. ResourceTrackerService는 노드매니저가 하트비트를 전송하지 않으면 해당 노드매니저를 재부텅할 것을 요청한다. 이때 ResourceTrackerService는 비동기 디스패처에게 이벤트 타입이 RMNodeEventType.REBOOTING인 이벤트 처리를 요청한다.
##### 2. 비동기 디스패처는 RMNodeEventType의 이벤트 핸들러인 NodeEventDispatcher의 handle 메소드를 호출해 이벤트 처리를 요청한다.
##### 3. NodeEventDispatcher의 handle 메소드는 RMNodeImpl의 handle 메소드를 호출한다.
##### 4. RMNodeImpl은 StateMachine의 doTransition 메소드를 호출해 상태를 변경한다. 변경 전 상태는 RUNNING과 UNHEALTHY가 될 수 있으며, 변경 후 상태는 REBOOTED로 설정된다. StateMachine은 상태가 변경되면 DeactivateNodeTransition 메소드를 호출한다.
##### 5. 재부팅된 노드매니저는 리소스매니저가 관리하는 노드매니저 목록에서 삭제돼야 한다. 이를 위해 DeactivateNodeTransition 메소드에서는 NodesListManagerEventType.NODE_UNUSABLE 이벤트를 요청한다.
