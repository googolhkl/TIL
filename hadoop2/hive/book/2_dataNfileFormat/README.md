# 데이터형과 파일 포맷
##### 하이브는 관계형 데이터베이스에서 볼 수 있는 여러 원시 데이터형을 지원할 뿐만 아니라 관계형 데이터베이스에서 거의 볼 수 없던 세 가지 종류의 컬렉션 데이터형을 지원한다.
##### 하이브는 다른 데이터베이스와 비교했을 때 하이브의 독특한 기능 중 하나는 파일에 데이터를 저장할 때 다양한 방법으로 인코딩할 수 있다는 유연성을 제공한다는 점이다.

## 1. 원시 데이터형
##### 하이브는 여러 크기의 정수형과 부동소수점 및 하나의 불린형과 임의의 길이를 가지는 문자열을 제공한다. 하이브 0.8.0 버전에서는 타임스탬프 데이터형 및 바이너리 데이터형이 추가되었다.

| 데이터형 | 크기 | 리터럴 문법 예제 |
| --- | --- | --- |
| TINYINT | 1바이트 크기의 정수 데이터형 | 20 |
| SMALLINT | 2바이트 크기의 정수 데이터형 | 20 |
| INT | 4바이트 크기의 정수 데이터형 | 20 |
| BIGINT | 8바이트 크기의 정수 데이터형 | 20 |
| BOOLEAN | TRUE 또는 FALSE | TRUE |
| FLOAT | 단정도 부동소수점 | 3.1415 |
| DOUBLE | 배정도 부동소수점 | 3.1415 |
| STRING | 문자의 시퀀스, 문자열 셋도 설정 가능<br />작은 따옴표 혹은 큰ㄷ 따옴표 사용 가능 | 'Now is the time',<br />"for all good men" |
| TIMESTAMP | 정수형, 부동소수점형, 문자열형 | 1327882394(유닉스 표준 타임스탬프),<br />1327882394.123456789(나노 초가 추가된 유닉스 표준 타임스탬프),<br />'2016-01-01 12:34:56.123456789'(JDBC 호한 java.SQL.Timestamp 포맷) |
| BINARY | 바이트의 배열 형태 지원 | 관계형 데이터베이스의 VARBINARY와 비슷 |

##### 다른 SQL 호환 언어처럼 하이브는 데이터형 이름의 대소문자 구분을 무시한다.<br />

##### 데이터형은 자바로 구현되어 있어서 자바 데이터형에서 동작하는 그대로 하이브에서도 동작한다. 예를 들어, STRING은 자바 String, FLOAT는 자바 float 등으로 구현했다.<br />

##### 새로 추가된 TIMESTAMP 데이터형은 유닉스 표준 시(1970년 1월1일 자정) 이후의 초로 해석되는 정수형, 유닉스 표준시 이후의 초로 해석되는 소수점 9자리까지를 나노 초로 가질 수 있는 부동소수점형, JDBC의 날짜 표현 규칙인 YYYY-MM-DD hh:mm:ss:fffffffff를 따라 해석되는 문자열이 될 수 있다.
##### TIMESTAMP 데이터형은 UTC 시간으로 해석된다. 하이브에서는 시간대에 따라 각각 변환하는 to_utc_timestamp, from_utc_timestamp를 내장 함수로 제공한다.<br />

##### 관계형 데이터베이스처럼  BLOB 데이터형의 데이터를 별도의 저장소에 저장하는 것과 달리 하이브는 BINARY 데이터형의 데이터를 레코드에 모두 저장한다.<br />



## 2. 컬렉션 데이터형
##### 하이브는 struct, map, array 칼럼을 지원한다. 아래 예제는 실제 하이브 내장 함수 호출이다.
| 데이터 형 | 설명 | 리터럴 문법 예제 |
| --- | --- | --- |
| STRUCT | C 언어의 구조체와 유사하다.<br />각각의 필드는 점 표기법으로 접근할 수 있다. 예를 들어, 'name'칼럼이 STRUCT{first STRING; last STRING]이라면 first필드를 name.first처럼 참조할 수 있다. | struct('John','Doe') |
| MAP | ['key']처럼 필드를 배열 표기법으로 접근할 수 있는 키-값 형태의 컬렉션 데이터형이다. 예를 들어, 'name' 컬럼이 'first'->'John', 'last'->'Doe'의 키-값을 가진 MAP이라면 마지막 name 값은 name['last']로 참조할 수 있다. | map('first', 'John', 'last', 'Doe') |
| ARRAY | 0으로 시작하는 정수로 색인할 수 있는 동일한 데이터형의 순차 시퀀스다. 예를 들어, 'name' 칼럼이 ['John', 'Doe']라는 값을 가진 ARRAY일 경우 두 번째 요소는 name[1]로 참조할 수 있다. | array('John', 'Doe') |



## 3. 데이터값의 텍스트 파일 인코딩
##### 우리는 쉼표로 필드를 구분하는 텍스트파일(CSV) 또는 탭으로 필드를 구분하는 텍스트파일(TSV)에 익숙하다. 하이브도 우리가 원한면 이러한 형식을 가진 텍스트 파일을 사용할 수 있으며 간단한 사용법을 보여줄 것이다. 그러나 이 두 가지 포맷은 단점이 있다. 이런 파일 포맷은 데이터 필드값에 쉼표 또는 탭이 있을 때 주의해야 한다. 이런 이유 때문에 하이브는 문자열의 값으로 잘 사용하지 않는 여러 제어 문자를 기본 구분 기호로 사용한다. 
| 구분 기호 | 설명 |
| --- | --- |
| \n | 텍스트 파일에서 각 줄은 하나의 레코드가 된다. 그러므로 줄 바꿈 문자는 레코드를 분리한다. |
| ^A | 모든칼 럼을 분리한다. CREATE TABLE 문에서 명시적으로 지정할 때는 8진수 코드 '\001'을 사용한다. |
| ^B | ARRAY, STRUCT 또는 MAP의 키-값 쌍의 요소를 분리한다. CREATE TABLE 문에서 명시적으로 지정할 때는 8진수 코드 '\002'를 사용한다. |
| ^C | MAP의 키-값 쌍에서 키를 관련된 값과 분리한다. CREATE TABLE 문에서 명시적으로 지정할 때는 8진수 코드 '\003'를 사용한다. |




## 4. Schema on Read
##### 전통 데이터베이스에서 외부 데이터 로딩, 쿼리 결과물 혹은 UPDATE 문 수행을 통하여 데이터를 쓸 때 데이터베이스는 데이터 저장소 모두를 제어한다. 데이터베이스는 문지기가 되는 것이다. 이것이 중요한 의미를 갖는 이유는 데이터베이스가 데이터를 쓸 때 스키마를 강제로 맞추려 하기 때문이다. 우리는 이것을 `schema on write`라고 부른다. <br />
##### 그러나 하이브는 저장소에 대해 그런 쓰기 제어를 가지고 있지 않다. 생성, 수정, 그리고 심지어 하이브가 쿼리할 데이터를 손상시키는 여러 방법이 있다. 하이브는 단지 쿼리 결과를 읽어 들일 때만 스키마를 적용한다. 이것을 `schema on read`라 부른다.<br />
##### 만약 스키마와 파일 내용이 일치하지 않으면 어떻게 될까? 하이브는 데이터를 읽을 때 할 수 있는 모든 최선을 다한다. 레코드에 스키마에서 정의한 모든 필드가 없다면 하이브는 그 값을 null로 채운다. 만약 숫자 필드가 정의되어 있는데 하이브가 숫자가 아닌 문자열을 만나면 하이브는 null값을 반환한다.
